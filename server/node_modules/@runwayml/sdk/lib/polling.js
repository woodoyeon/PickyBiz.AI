"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapAsWaitableResource = exports.AbortError = exports.TaskTimedOutError = exports.TaskFailedError = void 0;
const POLL_TIME = 6000; // 6 seconds
const POLL_JITTER = 3000; // 3 seconds
class TaskFailedError extends Error {
    constructor(taskDetails) {
        super(taskDetails.failure);
        this.taskDetails = taskDetails;
        this.name = 'TaskFailedError';
    }
}
exports.TaskFailedError = TaskFailedError;
class TaskTimedOutError extends Error {
    constructor(taskDetails) {
        super('Task timed out');
        this.taskDetails = taskDetails;
        this.name = 'TaskTimedOutError';
    }
}
exports.TaskTimedOutError = TaskTimedOutError;
class AbortError extends Error {
    constructor() {
        super('Polling aborted');
        this.code = 22;
        this.name = 'AbortError';
    }
}
exports.AbortError = AbortError;
function wrapAsWaitableResource(client) {
    return (responsePromise, skipInitialWait = false) => {
        return Object.defineProperty(responsePromise, 'waitForTaskOutput', {
            value: async (options) => {
                const wait = () => new Promise((resolve) => setTimeout(resolve, POLL_TIME + Math.random() * POLL_JITTER - POLL_JITTER / 2));
                if (!skipInitialWait) {
                    await wait();
                }
                const { timeout = 60 * 10 * 1000 } = options ?? {};
                const output = await responsePromise;
                const startTime = Date.now();
                let taskDetails;
                do {
                    if (options?.abortSignal?.aborted) {
                        throw new AbortError();
                    }
                    taskDetails = await client.tasks.retrieve(output.id);
                    if (taskDetails.status === 'SUCCEEDED') {
                        return taskDetails;
                    }
                    if (taskDetails.status === 'FAILED' || taskDetails.status === 'CANCELLED') {
                        throw new TaskFailedError(taskDetails);
                    }
                    await wait();
                    if (timeout != null && Date.now() - startTime > timeout && !options?.abortSignal?.aborted) {
                        throw new TaskTimedOutError(taskDetails);
                    }
                } while (['THROTTLED', 'PENDING', 'RUNNING'].includes(taskDetails.status));
                throw new TaskTimedOutError(taskDetails);
            },
            writable: false,
            enumerable: false,
            configurable: false,
        });
    };
}
exports.wrapAsWaitableResource = wrapAsWaitableResource;
//# sourceMappingURL=polling.js.map